<!DOCTYPE unspecified PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
		<h1>Intlib documentation - first DPU tutorial</h1>		
		Well to be honest some theory is hidden in this section but it's 
		connected with examplest so maybe you will find it usefull and
		interesing?
		<h2>Types of DPUs</h2>
        <div>The application distinguished three types of DPUs: 
        <ul>
            <li>Extractor - DPU which extract data from some source. 
            	This DPU type has only outputs.</li>
            <li>Transformer - DPU which transform input data into output data. 
            	This DPU has inputs as well as outputs.</li>
            <li>Loader - DPU which save into DB/File/etc.. 
            	This DPU has only inputs. </li>
         </ul>   
        </div>
	
		<h2>Logging the DPU's activity</h2>
		<div>Every DPU should log extensively. To log in your DPU, use slf4j. 
			The log for each DPU is stored and accessible to the user by the 
			graphical user interface of the application. Using sl4j is simple. 
			If you are not familiar with sl4j the following example 
			shows the basics.<br/>
			<div class="code"> <pre> <code>
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DPUTemplate  {
	private final LOG = LoggerFactory.getLogger(DPUTemplate.class);
...
			</code> </pre> </div>
			Just remember to replace DPUTemplate with your class's name. 
			Then when you want to log something just call:<br/>
			<div class="code"> 
			<pre> <code>LOG.debug("Some message .. ");</code> </pre> </div>
		</div>
	
		<h2 id="secConfigurationConcept">Configuration concept</h2>
		<div>Each DPU has possibility to store configuration that can configure 
			DPU execution. User can edit the configuration through the 
			configuration dialog which is also provided by DPU implementation. 
			<br/>
			The configuration is accessible as member variable.
			The configuration class must implement interface
			<div class="code"> <pre> <code>
interface cz.cuni.xrg.intlib.commons.configuration.DPUConfigObject {} .. </code> </pre> </div> 
			which is located in commons. The interface require implementation 
			of validation method. If you don't how to impelemnt it, just return
			true always.
			</div>
	
		<h2>DataUnit containers</h2> <div>
		Data between DPUs are passed in containers that are called 
		DataUnits. The DataUnit from the programmer's point of view is an 
		interface that does not offer any usable functionality. For 
		practical use, more specific interface is provided. Currently only 
		one interface is available: <i>RDFDataRepository</i>. 
		The DataUnit (ie. RDFDataRepository) can't be created directly. 
		To create DataUnit use DPU's <span class="inCode">Context</span>. </div>
					
		<h3>DataUnit - RDFDataRepository</h3> <div>
		The RDFDataRepository is RDF focused implementation of DataUnit. 
		Let's name few important function for work with RDFDataRepository 
		(to store RDF data being prepared by the DPU).
		<ul>
			<li><b>transformUsingSPARQL</b> - 
				Transform data in repository using given SPARQL query.</li>
			<li><b>addTripleToRepository</b> - 
				Add given triple into repository.</li>
			<li><b>extractRDFfromXMLFileToRepository</b> - 
				Read data from the given file and add them to the repository.</li>
		</ul> For more information about the methods please refer to the 
		<span class="inCode">RDFDataRepository</span> documentation. </div>
		                
        <h2 id="context">Context</h2> <div>
        Each DPU has execution context. It's main interface is 
		<span class="inCode">ProcessingContext</span> located in commons. 
		The DPU itself (extractor/transformer/loader) uses more special type 
		of <span class="inCode">Context</span> ie. 
		<span class="inCode">ExtractContext</span>, 
		<span class="inCode">TransformContext</span> or
		<span class="inCode">LoadContext</span>. The context provide ability 
		to send messages (events) that are stored and accessible to the user. 
		<br/>	Context also manages access to the input/output DataUnits. <br/> 
		
		The following example demonstrate this functionality for extractor: <br/>
<div class="code"> <pre> <code>
<span class="comment">// create output RDFDataRepository</span>
<span class="comment">// named "output_name"</span>
RDFDataRepository outputRepository = 
		(RDFDataRepository) context.addOutputDataUnit(DataUnitType.RDF, "output_name");
</code> </pre> </div>			
		 
		The following example demonstrate this functionality for loader: <br/>
<div class="code"> <pre> <code>
<span class="comment">// get first input as RDFDataRepository</span>
DataUnitList&lt;RDFDataRepository&gt; dataUnitList = RDFDataUnitList.create(context);
RDFDataRepository intputRepository = dataUnitList.getFirst();
</code> </pre> </div>		 
		 
		The following example demonstrate this functionality for transformer: <br/>
<div class="code"> <pre> <code>
<span class="comment">// get first input as RDFDataRepository</span>
DataUnitList&lt;RDFDataRepository&gt; dataUnitList = RDFDataUnitList.create(context);
RDFDataRepository intputRepository = dataUnitList.getFirst();
<span class="comment">// create output RDFDataRepository</span>
<span class="comment">// named "output_name"</span>
RDFDataRepository outputRepository = 
		(RDFDataRepository) context.addOutputDataUnit(DataUnitType.RDF, "output_name");
</code> </pre> </div>

		However the DataUnitList provide more functionality then just getFirst().
		In the following example we will pick fist DataUnit of type 
		RDFDataRepository with name "AStart":
<div class="code"> <pre> <code>
<span class="comment">// get first input as RDFDataRepository</span>
DataUnitList&lt;RDFDataRepository&gt; dataUnitList = RDFDataUnitList.create(context);
RDFDataRepository intputRepository = dataUnitList.filterByName("Astar").getFirst();
</code> </pre> </div>			
		If the required DataUnit is not present, then the exception about
		MissingInput is automatically thrown and the execution is terminated.
		</div>
	
		<h2>File management</h2> <div>
		This part is optional but can be useful if you plan to store DPU's working
		data in file. There are three places where DPU can store it's files.
		<ul>
			<li><b>working</b> - this directory is unique for single DPU,
			execution and user. Ie. only currently working DPU can see this
			directory = it's not shared with anybody.</li>
			<li><b>user</b> - this directory is unique for single DPU and
			execution. You can store DPU's user related data here. This execution
			can be accessed concurrently. This mean that two and more instances
			of your DPU's can work here, so keep this in mind when working 
			with this directory.</li>
			<li><b>global</b> - this directory is unique for single DPU. It's
			shared by different executions and users. You can store file that
			should be visible to your DPU any time.</li>
		</ul> 
		This directories can be obtained by specific context's methods. <br/>
		If you don't want to work with the directories directly or you don't like
		to care about current operating system to decide which file separators 
		to use or ... the <b>FileManager</b> comes to save the day. The 
		FileManager is class in common.module and it has been written to make
		your live easier. Let's demonstrate it's functionality on few examples.
		<br/>
		The following example demonstrates how to get path to the file in 
		working	directory: 
<div class="code"> <pre> <code>
<span class="comment">// create file manager</span>
FileManager fileManager = new FileManager(context);
<span class="comment">// file in working directory</span>
File filePath = fileManager.getWorking().file("myFile.txt");
</code> </pre> </div>
		The following example demonstrates hot to get path to the file in 
		some global sub-directory. The directory is automatically created for 
		you.
<div class="code"> <pre> <code>		 
<span class="comment">// create file manager</span>
FileManager fileManager = new FileManager(context);
<span class="comment">// file in sub-directory in global directory</span>
File filePath = fileManager.getGlobal().directory("myDir").file("myFile.txt");
</code> </pre> </div>		 
		 
		</div>
	
		<h2>Tutorial - Creation of Custom DPUs</h2> <div>
		This short tutorial will guide you through the process of the new data 
		processing unit (DPU) creation. <br/> It the following sections we will 
		go through the files prepared in the DPU template project 
		(which may be obtained from <a href="https://github.com/mff-uk/intlib">
		Github project site</a>, master branch, folder "module/DPU_template"), 
		from which you may derive your DPU implementation. 
		You may start by copying the "module/DPU_template" folder and opening 
		it in, e.g., Netbeans. You can also be inspired by the existing DPU 
		implementations in the folder "module". </div>
      
		<div> The template DPU contains 4 important files, which are typically 
		needed when new DPU is created. For each file, we explain in the 
		following sections its purpose and list the mandatory and optional 
		changes (called TODOs) that need to be done to implement DPU.</div>
        <div>For each DPU, you have to:
        <ul>
        	<li>adjust pom.xml containing basic metadata about the 
        		DPU implementation and definition of dependencies</li>
        	<li>define configuration class which implements 
        		<span class="inCode">Config</span> interface and holds 
        		configuration of the DPU</li>
        	<li>define the configuration dialog, which may be used by users 
        		of your DPU to set up the configuration of your DPU and 
        		extends 
        		<span class="inCode">BaseConfigDialog&lt;Config&gt;</span>. 
        		The configuration obtained from the dialog is stored to the 
        		configuration class</li>
        	<li>implement the class which executes the DPU - 
        		it contains the main functionality of the DPU and the 
        		functionality may be influenced by the configuration class</li>
        </ul> </div>

		<h3>pom.xml</h3>
		<div>The pom.xml file contains Maven configuration. 
		If you are not familiar with Maven then just ignore everything except 
		of several lines containing "TODOs", which needs your attention. 
		TODOs have assigned number to make it easy to follow.
		In next few lines we go through all of them and give brief comment 
		to each of them:
		<ul>
			<li><b>TODO 1. module_name: </b>
				The Maven's artifact's ID should be provided here. Maven uses 
				this name to identify the output module (jar) filename.	This 
				value should contains only a-z, A-Z, 0-9 and _ as whitespace. </li>				
			<li><b>TODO 2. DPU version: </b> In most common scenarios you can 
				leave the default value here. This value is stored in manifest.mf 
				file as "version of DPU". It correspond with Bundle-Version 
				in manifest.mf. </li>
			<li><b>TODO 3. DPU description: </b> DPU's description is visible 
				to the users. Provide all necessary information about your 
				intended DPU usage here. Provide contact details on the author
				 of the DPU.</li>
			<li><b>TODO 4. DPU package: </b> Specify the root (longest common) 
				package. If you use just one package, use it's name.</li>
			<li><b>TODO 5. DPU's 
				<span class="module_name">main_class_name</span>: </b> 
				Fill the DPU main class name. The main class must be placed in 
				package specified in the previous step.</li>
			<li> <b>TODO 6. Dependencies</b> Add your 
				project dependencies here. See the inplace examples 
				for more information.</li>
		</ul>
		<span class="warn"> Do not add dependencies elsewhere as they may not 
		be visible to the Maven.</span> </div>

		<h3>DPUTemplate.java</h3> <div>
		The DPU's main class. The name of the class and file must be 
		the same as <span class="module_name">main_class_name</span>. Thus, 
		rename the file and class in it according to 
		<span class="module_name">main_class_name</span>.As in pom.xml the
		template file contains "TODOs", places which requires your attention:
		<ul>
			<li><b>TODO 1.</b> First of all we need to change the extended base 
			class of the DPU.The following super classes are available: 
			<ul>
				<li><b>Extract</b> - Use if you implement new Extractor</li>
				<li><b>Transform</b> - Use if you implement new Transformer </li>
				<li><b>Load</b> - Use if you implement new Loader</li>
			</ul> 
			Each of these interfaces contains unique method that has to be 
			implemented. We return to this later.</li>
			<li><b>TODO 2.</b> Based on implemented interface (selected in TODO 1.) you have to provide implementation
			of one corresponding method required by that interface:
			<ul>
				<li><b>public extract(ExtractContext context)</b> for 
					<b>Extrac</b></li>				  			
				<li><b>public void transform(TransformContext context)</b> 
					for <b>Transfor</b></li>
				<li><b>public void load(LoadContext context)</b> for 
					<b>Load</b></li>
			  	</ul> 
			  	In this method the functionality of the DPU should be 
			  	implemented. All important data needed is passed to the 
			  	method as <a href="#context">Context</a>.
				</li>
			</ul>
			To make development easier we will not provide you with sample
			implementation of each module type: <br/>
			
            Sample transform() method for simple SPARQL transformer executing 
            the given SPARQL query:
<div class="code"> <pre> <code>
<span class="comment">// transform method which has to be implemented by DPU - transformer</span>
public void transform(TransformContext context) throws TransformException, DataUnitCreateException {
    <span class="comment">// get first input as RDFDataRepository</span>
    DataUnitList&lt;RDFDataRepository&gt; dataUnitList = RDFDataUnitList.create(context);
    RDFDataRepository intputRepository = dataUnitList.getFirst();
    <span class="comment">// create output </span>
    RDFDataRepository outputRepository = 
                    (RDFDataRepository) context.addOutputDataUnit(DataUnitType.RDF);
    <span class="comment">// query to be executed (obtained from the dialog) </span>            
    String updateQuery = config.getQuery();
    <span class="comment">// copies all data from input RDFDataRepository to 
    	output RDFDataRepository and transforms </span>
    intputRepository.copyAllDataToTargetRepository(outputRepository);
    outputRepository.transformUsingSPARQL(updateQuery);
}
</code> </pre> </div>
			Simple extract() method for extracting data from file.
<div class="code"> <pre> <code>			
public void extract(ExtractContext context)
	throws ExtractException,
		DataUnitCreateException {
	<span class="comment">// create output</span>
	RDFDataRepository repository = (RDFDataRepository) context
			.addOutputDataUnit(DataUnitType.RDF, "output");
	<span class="comment">// prepare configuration</span>
	final String baseURI = "";
	final FileExtractType extractType = config.fileExtractType;
	final String path = config.Path;
	final String fileSuffix = config.FileSuffix;
	final boolean onlyThisSuffix = config.OnlyThisSuffix;
	final boolean useStatisticHandler = config.UseStatisticalHandler;
	<span class="comment">// load data from file into DataUnit</span>
	try {
		repository.extractfromFile(extractType, path, fileSuffix, baseURI,
				onlyThisSuffix, useStatisticHandler);
	} catch (RDFException e) {
		throw new ExtractException(e.getMessage(), e);
	}
}			
		</code> </pre> </div>
			Simple load() method for loading data into file.
<div class="code"> <pre> <code>			
public void load(LoadContext context)
		throws LoadException,
			DataUnitException {
	<span class="comment">// create manager for input DataUnits</span>
	DataUnitList<RDFDataRepository> dataUnitList = RDFDataUnitList
			.create(context);
	<span class="comment">// get first DataUnit, the other we simply ignore</span>
	RDFDataRepository repository = dataUnitList.getFirst();
	<span class="comment">// prepare configuration</span>
	final String directoryPath = config.DirectoryPath;
	final String fileName = config.FileName;
	final RDFFormatType formatType = config.RDFFileFormat;
	final boolean isNameUnique = config.DiffName;
	final boolean canFileOverwritte = true;
	<span class="comment">// load data from DataUnit into file</span>
	try {
		repository.loadToFile(directoryPath, fileName, formatType,
				canFileOverwritte, isNameUnique);
	} catch (RDFException | CannotOverwriteFileException ex) {
		throw new LoadException(ex);
	}
}			
		</code> </pre> </div>			
		</div>
		
		<h3>DPUTemplateDialog.java</h3>	<div>
		This file contains implementation of DPU's configuration dialog. 
		The DPU's configuration dialog is implemented as a
		<a href="www.vaadin.com">Vaadin</a> component. The dialog
		class must extends abstract class
<div class="code"> <pre> <code>
cz.cuni.xrg.intlib.commons.module.dialog.BaseConfigDialog&lt;Config&gt;
</code> </pre> </div>
		</div>
			
		<h3>DPUTemplateConfig.java</h3>	<div>
		This file contains template for DPU's configuration. 
		It represents an object holding configuration needed by the DPU. 
		The class must implement interface 
<div class="code"> <pre> <code> 
cz.cuni.xrg.intlib.commons.configuration.DPUConfigObject
</code> </pre> </div> Put your configuration variables inside this class. 
		You can then access it from DPUTemplate class through the attribute
		<span class="inCode">config</span>. This class also require
		implementation of validation method, if you don't know how to
		implement it just return true always.</div>
				
		<h3>Compile DPU project</h3>
		Now when all updates and TODO are finished we are almost at the very 
		end of the tutorial. <br/>	
		To compile DPU project into output jar (bundle) file use 
		<b>mvn install</b> command.
		
		<h3>DPU-jar deploy</h3>
		The DPU jar file can be added to the Intlib through the web-application
		on page DPU. The same file should not be added twice, even under different 
		names. These may result into complication with using one of the DPU 
		in Intlib. To load new version of the jar-file please change it's 
		version in pom.xml or simply rewrite the old one in {project_path}\dpu. 
		
		
	</body>
</html>
 

